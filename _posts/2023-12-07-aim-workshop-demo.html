---
layout: post
title: "AIM Demo"
subtitle: "titles are hard"
header-img: "img/math-bg.png"
date: 2023-12-07 16:00:00
---

<script type="importmap">
    {
    "imports": {
        "@penrose/core": "https://ga.jspm.io/npm:@penrose/core@3.2.0/dist/index.js"
    },
    "scopes": {
        "https://ga.jspm.io/": {
        "@datastructures-js/queue": "https://ga.jspm.io/npm:@datastructures-js/queue@4.2.3/index.js",
        "@penrose/optimizer": "https://ga.jspm.io/npm:@penrose/optimizer@3.2.0/dist/index.js",
        "consola": "https://ga.jspm.io/npm:consola@2.15.3/dist/consola.browser.js",
        "crypto": "https://ga.jspm.io/npm:@jspm/core@2.0.1/nodelibs/browser/crypto.js",
        "immutable": "https://ga.jspm.io/npm:immutable@4.3.1/dist/immutable.es.js",
        "lodash": "https://ga.jspm.io/npm:lodash@4.17.21/lodash.js",
        "mathjax-full/js/": "https://ga.jspm.io/npm:mathjax-full@3.2.2/js/",
        "mhchemparser/dist/mhchemParser.js": "https://ga.jspm.io/npm:mhchemparser@4.2.1/dist/mhchemParser.js",
        "moo": "https://ga.jspm.io/npm:moo@0.5.2/moo.js",
        "nearley": "https://ga.jspm.io/npm:nearley@2.20.1/lib/nearley.js",
        "poly-partition": "https://ga.jspm.io/npm:poly-partition@1.0.2/lib/index.js",
        "seedrandom": "https://ga.jspm.io/npm:seedrandom@3.0.5/index.js",
        "true-myth": "https://ga.jspm.io/npm:true-myth@4.1.1/dist/cjs/index.js"
        }
    }
    }
</script>

<!-- ES Module Shims: Import maps polyfill for olrder browsers without import maps support (eg Safari 16.3) -->
<script
    async
    src="https://ga.jspm.io/npm:es-module-shims@1.7.3/dist/es-module-shims.js"
    crossorigin="anonymous"
></script>

<script src="
https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.0/dist/umd/supabase.min.js
"></script>

<script type="module">
    import { compile, optimize, toSVG, showError } from "@penrose/core";

    const producePenrose = (outcomes, resources, alignments, dependencies) => {

let substance = ""
outcomes.forEach(outcome => {
    substance += `Vertex o${outcome.name}\nAutoLabel o${outcome.name}\n`
});

substance += `\n`
resources.forEach(resource => {
    substance += `Vertex r${resource.name}\nAutoLabel r${resource.name}\n`
});

const variation = ''



const style = `canvas {
    width = 400
    height = 400
  }
  
  layout = [dots, loops, arrows, text]
  
  color {
    black = #000000
    white = #ffffff
  }
  
  num {
    radius = 5
    labelDist = 5
    edgeDist = 100
    repelDist = 1.5 * edgeDist
    offset = 10
    loopRadius = 15
    pointerX = 6
    pointerY = 4
  }
  
  forall Vertex v {
    v.dot = Circle {
      center: (? in dots, ? in dots)
      r: num.radius
      fillColor : color.black
    }
  
    v.text = Text {
      string: v.label
      fillColor: color.black
      fontFamily: "serif"
      fontSize: "18px"
      strokeColor: color.white
      strokeWidth: 4
      paintOrder: "stroke"
    }
    v.halfSize = (v.text.width / 2, v.text.height / 2)
    v.bottomLeft = v.text.center - v.halfSize
    v.topRight = v.text.center + v.halfSize
  
    v.text above v.dot
  
    encourage shapeDistance(v.dot, v.text) == num.labelDist in text
  }
  
  forall Vertex u; Vertex v {
    d = vdist(u.dot.center, v.dot.center)
    dHat = num.repelDist
    -- equation 6 from https://ipc-sim.github.io/
    encourage minimal(max(0, -sqr(d - dHat) * log(d / dHat))) in dots
  
    ensure disjoint(u.text, v.text, num.labelDist) in text
  }
  
  forall Vertex u; Vertex v; Link e where e := Arc(u, v) {
    a = u.dot.center
    b = v.dot.center
    t = normalize(b - a) -- tangent
    n = rot90(t) -- normal
    m = (a + b) / 2 -- midpoint
  
    e.start = a
    e.end = b
    e.theta = angleOf(t)
    e.offset = ? in dots
    e.arrow = Path {
      d: quadraticCurveFromPoints("open", [a, m + e.offset * n, b])
      strokeColor: color.black
    }
  
    e.step = ? in arrows
    e.pointerCenter = m + (e.offset / 2) * n + e.step * t
    p = e.pointerCenter
    x = num.pointerX
    y = num.pointerY
    e.pointer = Path {
      d: pathFromPoints("closed", [p - x * t + y * n, p + x * t, p - x * t - y * n])
      strokeColor: none()
      fillColor: color.black
    }
  
    e.arrow below u.dot
    e.arrow below v.dot
    e.pointer below e.arrow
  
    encourage vdist(u.dot.center, v.dot.center) < num.edgeDist in dots
    encourage minimal(sqr(e.offset)) in dots
    encourage minimal(sqr(e.step)) 
  }
  
  forall Vertex u; Vertex v; Link e1; Link e2 where e1 := Arc(u, v); e2 := Arc(u, v) {
    ensure abs(e2.offset - e1.offset) > 2 * num.offset in dots
  }
  
  forall Vertex u; Vertex v; Link e1; Link e2 where e1 := Arc(u, v); e2 := Arc(v, u) {
    ensure abs(e1.offset + e2.offset) > 2 * num.offset in dots
  }
  
  forall Vertex u; Vertex v; Link e where e := Arc(u, v); u has label {
    encourage maximal(min(num.labelDist, rectLineDist(u.bottomLeft, u.topRight, e.start, e.end))) in text
  }
  
  forall Vertex u; Vertex v; Link e where e := Arc(u, v); v has label {
    encourage maximal(min(num.labelDist, rectLineDist(v.bottomLeft, v.topRight, e.start, e.end))) in text
  }
  
  forall Vertex u; Vertex v; Vertex w; Link e where e := Arc(u, v); w has label {
    encourage maximal(min(num.labelDist, rectLineDist(w.bottomLeft, w.topRight, e.start, e.end))) in text
  }
  
  forall Vertex v; Link e where e := Arc(v, v) {
    e.theta = ? in loops
    n = (cos(e.theta), sin(e.theta)) -- normal
    delta = num.loopRadius * n
  
    e.arrow = Circle {
      center: v.dot.center + delta
      r: num.loopRadius
      strokeWidth: 1
      strokeColor: color.black
      fillColor: none()
    }
  
    t = rot90(n)
    p = v.dot.center + 2 * delta
    x = num.pointerX
    y = num.pointerY
    e.pointer = Path {
      d: pathFromPoints("closed", [p - x * t + y * n, p + x * t, p - x * t - y * n])
      strokeColor: none()
      fillColor: color.black
    }
  
    e.arrow below v.dot
    e.pointer below e.arrow
  }
  
  forall Vertex u; Vertex v; Link e1; Link e2 where e1 := Arc(u, v); e2 := Arc(v, v) {
    encourage maximal(cos(e2.theta - e1.theta)) in loops
  }
  
  forall Vertex u; Vertex v; Link e1; Link e2 where e1 := Arc(v, u); e2 := Arc(v, v) {
    encourage minimal(cos(e2.theta - e1.theta)) in loops
  }
  
  forall Link e1, e2
  where e1 := Arc(a, b); e2 := Arc(c, d)
  with Vertex a, b, c, d {
    ensure norm(e2.pointerCenter - e1.pointerCenter) > max(num.pointerX, num.pointerY)*3 in arrows
    encourage e1.step == e2.step
  }
  `

  const domain = `type Vertex
  type Link
  constructor Arc(Vertex u, Vertex v) -> Link
  `


  return { style, domain, substance, variation }
}


const outcomesResponse = await supabase
        .from('outcomes')
        .select('id')
const resourcesResponse = await supabase
        .from('outcomes')
        .select('id')
    const compiled = await compile(producePenrose(
        outcomesResponse.data,
        resourcesResponse.data
    ));
    if (compiled.isErr()) console.error(showError(compiled.error));
    const optimized = optimize(compiled.value);
    if (optimized.isErr()) console.error(showError(optimized.error));
    document
    .getElementById("penrose")
    .appendChild(await toSVG(optimized.value));
</script>
<div id="penrose"></div>
